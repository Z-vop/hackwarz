<!DOCTYPE html>
<html lang="en">
<head>
    <style>
        html,
        body {
            margin: 0;
            overflow: hidden;
            height: 100%;
            background: black;
        }

        canvas[resize] {
            width: 100%;
            height: 100%;
        }

    </style>
    <meta charset="UTF-8">
    <title>Hackwarz Network Editor</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.10.3/paper-full.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.7.3/socket.io.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.js"></script>
    <script src="/hw_graphics.js"></script>
    <script>
        // Only execute our code once the DOM is ready.

        // TODO: Replace array with Redux state
        var addedObjects = [];


        window.onload = function () {

            var canvas = document.getElementById('myCanvas');
            paper.setup(canvas);
            view.draw();

            // x, y, radius, owner
            var networkData =  [
                [780, 337, 95, 0],
                [763, 142, 35, 0],
                [891, 186, 35, 0],
                [968, 287, 35, 0],
                [954, 411, 35, 0],
                [860, 509, 35, 0],
                [725, 523, 35, 0],
                [600, 424, 35, 0],
                [579, 283, 35, 0],
                [650, 174, 35, 0],
                [514, 354, 15, 0],
                [557, 191, 15, 0],
                [686, 94, 15, 0],
                [843, 100, 15, 0],
                [989, 197, 15, 0],
                [1035, 363, 15, 0],
                [966, 516, 15, 0],
                [802, 597, 15, 0],
                [608, 532, 15, 0],
                [469, 248, 25, 0],
                [585, 78, 25, 0],
                [765, 42, 25, 0],
                [954, 101, 25, 0],
                [1077, 271, 25, 0],
                [1062, 464, 25, 0],
                [912, 601, 25, 0],
                [672, 610, 25, 0],
                [493, 472, 25, 0],
                [1359, 71, 25, 2],  // red nodes
                [1375, 308, 25, 2],
                [1375, 521, 25, 2],
                [260, 87, 25, 1],   // blue nodes
                [261, 300, 25, 1],
                [260, 559, 25, 1]];

            // This tool allows us to draw lines between nodes
            connectTool = new Node(150, 330, 10, "#f49542");
            connectTool.onMouseDown = function () {
                if (this.selected == false) {
                    this.selected = true;
                } else this.selected = false;
            };

            // Draws the network map from the array
            for(i=0;i<networkData.length;i++){
                var thenode = networkData[i];
                var newnode = new Node(thenode[0],thenode[1],thenode[2],'grey');
                newnode.owner = thenode[3];
                addedObjects.push(newnode);
            }


            paper.view.onMouseDown = function (event) {
                var hitOptions = {
                    //class: Path,
                    //segments: false,
                    stroke: true,
                    fill: true,
                    tolerance: 5
                };
                var hitResult = paper.project.hitTest(event.point, hitOptions);

                if (hitResult) {                                    // Are we clicking on an existing object?
                    var item;
                    if (hitResult.item.parent instanceof Node) {    // Find either the Node or the Path object
                        item = hitResult.item.parent;
                    } else {
                        item = hitResult.item;
                    }



                    if (item instanceof Node && (item !== connectTool)) {                     // Did we click on a Node?
                        const clickedNode = item;  // just to make code clearer
                        item.selected = (!clickedNode.selected);

                        if (connectTool.selected) {
                            if (countSelectedNodes() > 1) {
                                connectAllNodes(getSelectedNodes());
                                deselectNodes(getSelectedNodes());
                            }
                        }

                        if (true /*!clickedNode.owned*/) {   // They clicked on a green node
                            getConnectedPaths(clickedNode).forEach(function (line) {  // for each line that is connected to the clicked-on Node
                                // Test the node at the end of each line
                                // Find out whether the other node is node1 or node2
                                var connectedNode = (clickedNode.id == line.node1.id) ? line.node2 : line.node1;
                                // If the node is owned and selected
                                if (connectedNode.owned && connectedNode.selected) {
                                    // Attack is successful, change node color
                                    // TODO: Need to make attacks more sophisticated
                                    // We need to just note the line where an attack is happening, and then process the
                                    // attacks somewhere else in the onFrame event probably.
                                    clickedNode.owner = connectedNode.owner;
                                    connectedNode.selected = false;
                                    clickedNode.selected = false;
                                }
                            }); // END each connected line
                        } // END clicked node not owned
                    } // END clicked a Node
                } // END hit result
            } // END mouseDown
        }; //END OnLoad

//        view.onFrame = function (event) {
//            // event.count is the number of times the frame event has been fired
//            if (event.count % 60 == 0) { // 60 frames per second
//
//                if (health > 0) {
//                    health -= 5;
//                }
//
//                if (health <= 0) {
//                    item.baseColor = "#4286f4"; // blue
//                    item.targeted = false;
//                }
//            } // end once_per_second
//
//            if (event.count % 1 == 0 && health > 0) {
//                //console.log(health, tempColor.toString(), tempColor.toCSS(), tempColor.brightness, brighter);
//
//                if (tempColor.brightness <= 0.45) {
//                    brighter = true;
//                } else if (tempColor.brightness >= 0.80) {
//                    brighter = false;
//                }
//
//                if (brighter == false) {
//                    tempColor.brightness -= 0.01;
//                } else if (brighter == true) {tempColor.brightness += 0.01;
//                }
//                item.baseColor = tempColor;
//
//            } // end 5_times_per_second
//        };//end onFrame

        /* COMMON FUNCTIONS */

        // Return true if the node has an owner
        function isOwned(node) {
            if (!(node instanceof Node)) return false;
            return node.owned;
        }

        // Return an array of all Nodes
        function getNodes() {
            return addedObjects.filter(function (item) {
                return item instanceof Node
            });
        }

        // Return an array of all the selected nodes
        function getSelectedNodes() {
            return getNodes().filter(function (item) {
                return item.selected;
                return item.r;
            });
        }

        // Return a count of selected nodes
        function countSelectedNodes() {
            return getSelectedNodes().length;
        }

        // Remove a Node or Path from the addedObjects array
        function removeObject(item) {
            // If the item is a Node and it is connected, remove each connected line
            if (item instanceof Node) {
                getConnectedPaths(item).forEach(removeObject);
            }
            item.remove();
            index = addedObjects.findIndex(function (testItem) {
                return testItem.id == item.id;
            });
            if (index != -1) addedObjects.splice(index, 1);
        }


        // Connect an array of Node objects
        function connectAllNodes(nodesArray) {
            for (var i = 0; i < nodesArray.length - 1; i++) {
                addedObjects.push(connectNodes(nodesArray[i], nodesArray[i + 1]));
            }
        }

        // Deselect an array of Node objects
        function deselectNodes(nodes) {
            for (var i = 0; i < nodes.length; i++) nodes[i].selected = false;
        }


        // Return true if given line is connected to the given node
        function LineIsConnectedToNode(line, node) {
            if (!(line instanceof Path)) return false;
            if (!(node instanceof Node)) return false;
            return (line.node1.id == node.id || line.node2.id == node.id);
        }

        // Return an array of all of the Path items (PaperJS Line objects currently)
        function getPaths() {
            return addedObjects.filter(function (item) {
                return item instanceof Path
            });
        }

        // Return an array of all paths connected to given node
        function getConnectedPaths(node) {
            if (!(node instanceof Node)) return [];

            return getPaths().filter(function (path) {
                return LineIsConnectedToNode(path, node)
            });
        }

    </script>


</head>
<body>
<canvas id="myCanvas" resize></canvas>
</body>
</html>




